| Aspecto                  | v1                                                        | v2                                                             | Melhorias / Observações                                                                                       |
|--------------------------|-----------------------------------------------------------|----------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|
| **Board representation** | `Array<CharArray>` (8x8)                                  | `BitBoard` com 2 bits por célula, 2 Longs                      | Redução de memória: de 128 bytes para 16 bytes. Mais eficiente, menos overhead.                               |
| **Cell values**          | Constantes `player1 = '@'`, `player2 = '#'`, `cell = '.'` | Constantes `EMPTY = 0`, `PLAYER1 = 1`, `PLAYER2 = 2`           | Mantém valores fixos, permite operações bit a bit e contagem eficiente.                                       |
| **Player representation**| Constantes `player1`/`player2`                            | `enum class Player2`                                           | Facilita obtenção do adversário (`opponent()`), aumenta clareza, evita magic numbers.                        |
| **Move representation**  | `Pair<Int, Int>`                                          | `value class Move(val position: Pair<Int, Int>)`               | Type-safe, zero-overhead, mais expressivo.                                                                    |
| **Game state**           | Verificação ad-hoc de fim de jogo                         | `enum class GameState` com método `evaluate`                   | Mais estruturado, fácil de estender, melhora legibilidade.                                                    |
| **CLI**                  | `ReversiCLI` com parsing básico                           | `ReversiCLI2`, parse de comandos, highlight de jogadas válidas | Experiência mais amigável, validMoves destacados, cores aplicadas aos players.                                |
| **Board printing**       | CLI imprime o board diretamente                           | `BitBoard.printBoard()` + `ReversiGame2.printGame()`           | Separação de responsabilidades: `BitBoard` conhece a representação, `ReversiGame2` organiza o estado do jogo. |
| **Move validation**      | Código espalhado pelo jogo                                | `ReversiGame2.hasCapture()` + `getValidMoves()`                | Mais modular, reutilizável, fácil de testar.                                                                  |
| **Memory e performance** | Menos otimizado                                           | Uso de bit operations e `Long` para representar board          | Menor footprint de memória, operações mais rápidas de contagem e acesso.                                      |
| **Extensibilidade**      | Difícil de adicionar features                             | Estrutura de enums, value classes, BitBoard                    | Facilita adicionar features futuras, e.g., diferentes tamanhos de board ou modos de jogo.                     |
